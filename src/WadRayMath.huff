
/* Interface */
#define function wadMul(uint256,uint256) nonpayable returns (uint256)
#define function wadDiv(uint256,uint256) nonpayable returns (uint256)
#define function rayMul(uint256,uint256) nonpayable returns (uint256)
#define function rayDiv(uint256,uint256) nonpayable returns (uint256)
#define function rayToWad(uint256) nonpayable returns (uint256)
#define function wadToRay(uint256) nonpayable returns (uint256)

 

/* Constants*/
#define constant WAD = 0xde0b6b3a7640000
#define constant HALF_WAD = 0x6f05b59d3b20000
#define constant RAY = 0x33b2e3c9fd0803ce8000000
#define constant HALF_RAY = 0x19d971e4fe8401e74000000
#define constant WAD_RAY_RATIO = 0x3b9aca00
#define constant TYPE_UINT_MAX =  0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

 

/* Methods */
#define macro WAD_MUL() = takes (0) returns (0) {

    /// Short circuit: Return zero if one of the inputs are zero
    0x04 calldataload           // [num1]  
    dup1                        // [num1, num1]       
    iszero return_zero jumpi    // [num1==0, num1] 
    
    0x24 calldataload           // [num2, num1]
    dup1                        // [num2, num2, num1]
    iszero return_zero jumpi    // [num2==0, num2, num1]
     

    [HALF_WAD]                  // [HALF_WAD, num2, num1]
    [TYPE_UINT_MAX]             // [UINT_MAX, HALF_WAD, num2, num1]
    sub                         // [UINT_MAX-HALF_WAD, num2, num1]
    dup2                        // [num2,UINT_MAX-HALF_WAD,num2, num1]    
    dup2                        // [UINT_MAX-HALF_WAD,num2,UINT_MAX-HALF_WAD,num2, num1]   
    div                         // [(UINT_MAX-HALF_WAD / num2),UINT_MAX-HALF_WAD,num2, num1]
    dup4                        // [num1, (UINT_MAX-HALF_WAD / num2),UINT_MAX-HALF_WAD,num2, num1]
    swap1                       // [(UINT_MAX-HALF_WAD / num2),num1,UINT_MAX-HALF_WAD,num2, num1]
    gt return_result jumpi      // [(UINT_MAX-HALF_WAD / num2) > num1,UINT_MAX-HALF_WAD,num2, num1]
    
    return_zero:
        0x00                    // [0]
        0x00 mstore             // []
        0x20 0x00 return        // []
    
    return_result:
        pop                     // [num2, num1]  
        mul                     // [num2 * num1]  
        [HALF_WAD]              // [HALF_WAD, num2*num1]
        add                     // [HALF_WAD + (num2*num1)]
        [WAD]                   // [1e18, HALF_WAD + (num2*num1)]
        swap1                   // [HALF_WAD + (num2*num1),1e18]
        div                     // [HALF_WAD + (num2*num1) / 1e18]
        0x00 mstore             // []
        0x20 0x00 return        // []

}


#define macro WAD_DIV() = takes (0) returns (0) {
    0x04 calldataload           // [num1]     
    0x24 calldataload           // [num2, num1]
    dup1                        // [num2, num2, num1]
    iszero revert_tx jumpi      // [num2==0, num2, num1]    
    
    0x02                        // [2, num2, num1]
    swap1                       // [num2, 2, num1]    
    div                         // [num2/2, num1]
    dup1                        // [num2/2, num2/2, num1]
    0x00 mstore                 // [num2/2, num1]    
    [TYPE_UINT_MAX]             // [UINT_MAX, num2/2, num1]
    sub                         // [UINT_MAX-num2/2, num1]
    [WAD]                       // [1e18, UINT_MAX - num2 / 2, num1]
    dup2                        // [UINT_MAX - num2 / 2, 1e18, UINT_MAX - num2 / 2, num1]
    div                         // [(UINT_MAX - (num2 / 2)) / 1e18, UINT_MAX - num2 / 2, num1]
    dup3                        // [num1, (UINT_MAX - (num2 / 2)) / 1e18, UINT_MAX - num2 / 2, num1]
    swap1                       // [(UINT_MAX - (num2 / 2)) / 1e18, num1, UINT_MAX - num2 / 2, num1]
    gt return_result jumpi      // [(UINT_MAX - (num2 / 2)) / 1e18 > num1, UINT_MAX - num2 / 2, num1] 
    
    revert_tx:
        revert

     return_result:
        pop                     // [num1] 
        [WAD]                   // [1e18, num1]
        dup2                    // [num1, 1e18, num1]
        mul                     // [num1 * 1e18, num1]
        0x00 mload              // [num2/2, num1 * 1e18, num1]
        add                     // [num2/2 + num1 * 1e18, num1]
        0x00 mload              // [num2/2, num2/2 + num1*1e18, num1]
        0x02                    // [2,num2/2, num2/2 + num1*1e18, num1]
        mul                     // [num2, num2/2 + num1*1e8, num1]
        swap1                   // [num2/2 + num1 *1e18, num2, num1 ]
        div                     // [(num2/2 + num1 *1e18) / num2, num1 ]    
        0x00 mstore             // [num1]
        0x20 0x00 return        // [num1]
}


#define macro RAY_MUL() = takes (0) returns (0) {

    0x04 calldataload           // [num1]  
    dup1                        // [num1, num1]       
    iszero return_zero jumpi    // [num1==0, num1] 
    
    0x24 calldataload           // [num2, num1]
    dup1                        // [num2, num2, num1]
    iszero return_zero jumpi    // [num2==0, num2, num1]
     

    [HALF_RAY]                  // [HALF_RAY, num2, num1]
    [TYPE_UINT_MAX]             // [UINT_MAX, HALF_RAY, num2, num1]
    sub                         // [UINT_MAX-HALF_RAY, num2, num1]
    dup2                        // [num2,UINT_MAX-HALF_RAY,num2, num1]    
    dup2                        // [UINT_MAX-HALF_RAY,num2,UINT_MAX-HALF_RAY,num2, num1]   
    div                         // [(UINT_MAX-HALF_RAY / num2),UINT_MAX-HALF_RAY,num2, num1]
    dup4                        // [num1, (UINT_MAX-HALF_RAY / num2),UINT_MAX-HALF_RAY,num2, num1]
    swap1                       // [(UINT_MAX-HALF_RAY / num2),num1,UINT_MAX-HALF_RAY,num2, num1]
    gt return_result jumpi      // [(UINT_MAX-HALF_RAY / num2) > num1,UINT_MAX-HALF_RAY,num2, num1]
    
    return_zero:
        0x00                    // [0]
        0x00 mstore             // []
        0x20 0x00 return        // []
    
    return_result:
        pop                     // [num2, num1]  
        mul                     // [num2 * num1]  
        [HALF_RAY]              // [HALF_RAY, num2*num1]
        add                     // [HALF_RAY + (num2*num1)]
        [RAY]                   // [1e27, HALF_RAY + (num2*num1)]
        swap1                   // [HALF_RAY + (num2*num1),1e27]
        div                     // [HALF_RAY + (num2*num1) / 1e27]
        0x00 mstore             // []
        0x20 0x00 return        // []

}

#define macro RAY_DIV() = takes (0) returns (0) {
    0x04 calldataload           // [num1]     
    0x24 calldataload           // [num2, num1]
    dup1                        // [num2, num2, num1]
    iszero revert_tx jumpi      // [num2==0, num2, num1]    
    
    0x02                        // [2, num2, num1]
    swap1                       // [num2, 2, num1]    
    div                         // [num2/2, num1]
    dup1                        // [num2/2, num2/2, num1]
    0x00 mstore                 // [num2/2, num1]    
    [TYPE_UINT_MAX]             // [UINT_MAX, num2/2, num1]
    sub                         // [UINT_MAX-num2/2, num1]
    [RAY]                       // [1e27, UINT_MAX - num2 / 2, num1]
    dup2                        // [UINT_MAX - num2 / 2, 1e27, UINT_MAX - num2 / 2, num1]
    div                         // [(UINT_MAX - (num2 / 2)) / 1e27, UINT_MAX - num2 / 2, num1]
    dup3                        // [num1, (UINT_MAX - (num2 / 2)) / 1e27, UINT_MAX - num2 / 2, num1]
    swap1                       // [(UINT_MAX - (num2 / 2)) / 1e27, num1, UINT_MAX - num2 / 2, num1]
    gt return_result jumpi      // [(UINT_MAX - (num2 / 2)) / 1e27 > num1, UINT_MAX - num2 / 2, num1] 
    
    revert_tx:
        revert

     return_result:
        pop                     // [num1] 
        [RAY]                   // [1e27, num1]
        dup2                    // [num1, 1e27, num1]
        mul                     // [num1 * 1e27, num1]
        0x00 mload              // [num2/2, num1 * 1e27, num1]
        add                     // [num2/2 + num1 * 1e27, num1]
        0x00 mload              // [num2/2, num2/2 + num1*1e27, num1]
        0x02                    // [2,num2/2, num2/2 + num1*1e27, num1]
        mul                     // [num2, num2/2 + num1*1e8, num1]
        swap1                   // [num2/2 + num1 *1e27, num2, num1 ]
        div                     // [(num2/2 + num1 *1e27) / num2, num1 ]    
        0x00 mstore             // [num1]
        0x20 0x00 return        // [num1]
}


#define macro RAY_TO_WAD() = takes (0) returns (0) {
    0x04 calldataload    
    dup1 iszero return_zero jumpi
    [WAD_RAY_RATIO]
    dup1
    0x02
    swap1
    div
    dup3
    
    add
    dup1
    dup3
     
    lt return_result jumpi
    revert
    
    return_result:
    pop
    swap1
    div
    0x00 mstore
    0x20 0x00 return

    return_zero:
        0x00
        0x00 mstore
        0x20 0x00 return
}


#define macro WAD_TO_RAY() = takes (0) returns (0) {
    0x04 calldataload    
    dup1 iszero return_zero jumpi

    [WAD_RAY_RATIO]
    dup1
    dup3
    mul
    dup1
    dup3
    swap1
    div
    
    dup4
    eq iszero overflow jumpi
    0x00 mstore
    0x20 0x00 return
     
    return_zero:
        0x00
        0x00 mstore
        0x20 0x00 return
        
    overflow:
        revert
}
 

#define macro MAIN() = takes (0) returns (0) {
    // Identify which function is being called.
    0x00 calldataload 
    
    // Extract the function signature
    0xe0 shr

    // Jump table
    dup1 __FUNC_SIG(wadMul) eq  wad_mul jumpi
    dup1 __FUNC_SIG(wadDiv) eq  wad_div jumpi
    dup1 __FUNC_SIG(rayMul) eq  ray_mul jumpi
    dup1 __FUNC_SIG(rayDiv) eq  ray_div jumpi
    dup1 __FUNC_SIG(rayToWad) eq  ray_to_wad jumpi
    dup1 __FUNC_SIG(wadToRay) eq  wad_to_ray jumpi


    wad_mul:
        WAD_MUL()

    wad_div:
        WAD_DIV()  

    ray_mul:
        RAY_MUL()  

    ray_div:
        RAY_DIV() 

    ray_to_wad:
        RAY_TO_WAD() 

    wad_to_ray:
        WAD_TO_RAY() 

}



 