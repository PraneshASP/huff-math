

/* Constants*/
#define constant WAD = 0xde0b6b3a7640000
#define constant HALF_WAD = 0x6f05b59d3b20000
#define constant RAY = 0x33b2e3c9fd0803ce8000000
#define constant HALF_RAY = 0x19d971e4fe8401e74000000
#define constant WAD_RAY_RATIO = 0x3b9aca00
#define constant TYPE_UINT_MAX =  0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

 

/* Methods */
#define macro WAD_MUL() = takes (2) returns (1) {
    // Input Stack:             // [b, a]
    [HALF_WAD]                  // [HALF_WAD, b, a]
    [TYPE_UINT_MAX]             // [UINT_MAX, HALF_WAD, b, a]
    sub                         // [UINT_MAX-HALF_WAD, b, a]
    dup2                        // [b,UINT_MAX-HALF_WAD,b, a]    
    dup2                        // [UINT_MAX-HALF_WAD,b,UINT_MAX-HALF_WAD,b, a]   
    div                         // [(UINT_MAX-HALF_WAD / b),UINT_MAX-HALF_WAD,b, a]
    dup4                        // [a, (UINT_MAX-HALF_WAD / b),UINT_MAX-HALF_WAD,b, a]
    swap1                       // [(UINT_MAX-HALF_WAD / b),a,UINT_MAX-HALF_WAD,b, a]
    gt return_result jumpi      // [(UINT_MAX-HALF_WAD / b) > a,UINT_MAX-HALF_WAD,b, a]
    0x00 0x00 revert
   
    
    return_result:
        pop                     // [b, a]  
        mul                     // [b * a]  
        [HALF_WAD]              // [HALF_WAD, b*a]
        add                     // [HALF_WAD + (b*a)]
        [WAD]                   // [1e18, HALF_WAD + (b*a)]
        swap1                   // [HALF_WAD + (b*a),1e18]
        div                     // [HALF_WAD + (b*a) / 1e18]
        // Return Stack         // [HALF_WAD + (b*a) / 1e18]
}


#define macro WAD_DIV() = takes (0) returns (0) {
    0x04 calldataload           // [a]     
    0x24 calldataload           // [b, a]
    dup1                        // [b, b, a]
    iszero revert_tx jumpi      // [b==0, b, a]    
    
    0x02                        // [2, b, a]
    swap1                       // [b, 2, a]    
    div                         // [b/2, a]
    dup1                        // [b/2, b/2, a]
    0x00 mstore                 // [b/2, a]    
    [TYPE_UINT_MAX]             // [UINT_MAX, b/2, a]
    sub                         // [UINT_MAX-b/2, a]
    [WAD]                       // [1e18, UINT_MAX - b / 2, a]
    dup2                        // [UINT_MAX - b / 2, 1e18, UINT_MAX - b / 2, a]
    div                         // [(UINT_MAX - (b / 2)) / 1e18, UINT_MAX - b / 2, a]
    dup3                        // [a, (UINT_MAX - (b / 2)) / 1e18, UINT_MAX - b / 2, a]
    swap1                       // [(UINT_MAX - (b / 2)) / 1e18, a, UINT_MAX - b / 2, a]
    gt return_result jumpi      // [(UINT_MAX - (b / 2)) / 1e18 > a, UINT_MAX - b / 2, a] 
    
    revert_tx:
        revert

     return_result:
        pop                     // [a] 
        [WAD]                   // [1e18, a]
        dup2                    // [a, 1e18, a]
        mul                     // [a * 1e18, a]
        0x00 mload              // [b/2, a * 1e18, a]
        add                     // [b/2 + a * 1e18, a]
        0x00 mload              // [b/2, b/2 + a*1e18, a]
        0x02                    // [2,b/2, b/2 + a*1e18, a]
        mul                     // [b, b/2 + a*1e8, a]
        swap1                   // [b/2 + a *1e18, b, a ]
        div                     // [(b/2 + a *1e18) / b, a ]    
        0x00 mstore             // [a]
        0x20 0x00 return        // [a]
}


#define macro RAY_MUL() = takes (0) returns (0) {

    0x04 calldataload           // [a]  
    dup1                        // [a, a]       
    iszero return_zero jumpi    // [a==0, a] 
    
    0x24 calldataload           // [b, a]
    dup1                        // [b, b, a]
    iszero return_zero jumpi    // [b==0, b, a]
     

    [HALF_RAY]                  // [HALF_RAY, b, a]
    [TYPE_UINT_MAX]             // [UINT_MAX, HALF_RAY, b, a]
    sub                         // [UINT_MAX-HALF_RAY, b, a]
    dup2                        // [b,UINT_MAX-HALF_RAY,b, a]    
    dup2                        // [UINT_MAX-HALF_RAY,b,UINT_MAX-HALF_RAY,b, a]   
    div                         // [(UINT_MAX-HALF_RAY / b),UINT_MAX-HALF_RAY,b, a]
    dup4                        // [a, (UINT_MAX-HALF_RAY / b),UINT_MAX-HALF_RAY,b, a]
    swap1                       // [(UINT_MAX-HALF_RAY / b),a,UINT_MAX-HALF_RAY,b, a]
    gt return_result jumpi      // [(UINT_MAX-HALF_RAY / b) > a,UINT_MAX-HALF_RAY,b, a]
    
    return_zero:
        0x00                    // [0]
        0x00 mstore             // []
        0x20 0x00 return        // []
    
    return_result:
        pop                     // [b, a]  
        mul                     // [b * a]  
        [HALF_RAY]              // [HALF_RAY, b*a]
        add                     // [HALF_RAY + (b*a)]
        [RAY]                   // [1e27, HALF_RAY + (b*a)]
        swap1                   // [HALF_RAY + (b*a),1e27]
        div                     // [HALF_RAY + (b*a) / 1e27]
        0x00 mstore             // []
        0x20 0x00 return        // []

}

#define macro RAY_DIV() = takes (0) returns (0) {
    0x04 calldataload           // [a]     
    0x24 calldataload           // [b, a]
    dup1                        // [b, b, a]
    iszero revert_tx jumpi      // [b==0, b, a]    
    0x02                        // [2, b, a]
    swap1                       // [b, 2, a]    
    div                         // [b/2, a]
    dup1                        // [b/2, b/2, a]
    0x00 mstore                 // [b/2, a]    
    [TYPE_UINT_MAX]             // [UINT_MAX, b/2, a]
    sub                         // [UINT_MAX-b/2, a]
    [RAY]                       // [1e27, UINT_MAX - b / 2, a]
    dup2                        // [UINT_MAX - b / 2, 1e27, UINT_MAX - b / 2, a]
    div                         // [(UINT_MAX - (b / 2)) / 1e27, UINT_MAX - b / 2, a]
    dup3                        // [a, (UINT_MAX - (b / 2)) / 1e27, UINT_MAX - b / 2, a]
    swap1                       // [(UINT_MAX - (b / 2)) / 1e27, a, UINT_MAX - b / 2, a]
    gt return_result jumpi      // [(UINT_MAX - (b / 2)) / 1e27 > a, UINT_MAX - b / 2, a] 
    
    revert_tx:
        revert

     return_result:
        pop                     // [a] 
        [RAY]                   // [1e27, a]
        dup2                    // [a, 1e27, a]
        mul                     // [a * 1e27, a]
        0x00 mload              // [b/2, a * 1e27, a]
        add                     // [b/2 + a * 1e27, a]
        0x00 mload              // [b/2, b/2 + a*1e27, a]
        0x02                    // [2,b/2, b/2 + a*1e27, a]
        mul                     // [b, b/2 + a*1e8, a]
        swap1                   // [b/2 + a *1e27, b, a ]
        div                     // [(b/2 + a *1e27) / b, a ]    
        0x00 mstore             // [a]
        0x20 0x00 return        // [a]
}


#define macro RAY_TO_WAD() = takes (0) returns (0) {
    0x04 calldataload           // [num]        
    dup1                        // [num, num]        
    iszero                      // [num==0, num]
    return_zero jumpi           // [num]    
    [WAD_RAY_RATIO]             // [1e9, num]
    dup1                        // [1e9, 1e9, num]
    0x02                        // [2, 1e9, 1e9, num]
    swap1                       // [1e9, 2, 1e9, num]
    div                         // [1e9/2, 1e9, num]
    dup3                        // [num, 1e9/2, 1e9, num]
    add                         // [num + 1e9/2,1e9,num]
    dup1                        // [num+1e9/2, num+1e9/2, 1e9, num]    
    dup3                        // [num, num+1e9/2, num+1e9/2, 1e9, num]
    lt                          // [num < num+(1e9/2),num+1e9/2, 1e9, num]  
    return_result jumpi         // [num+1e9/2, 1e9, num]
    revert

    return_result:
    pop                         // [1e9, num]    
    swap1                       // [num, 1e9]
    div                         // [num / 1e9]
    0x00 mstore                 // []
    0x20 0x00 return            // []

    return_zero:
        0x00                    // [0]
        0x00 mstore             // []
        0x20 0x00 return        // []
}


#define macro WAD_TO_RAY() = takes (0) returns (0) {
    0x04 calldataload           // [num]               
    dup1                        // [num, num]
    iszero return_zero jumpi    // [num == 0, num]
    [WAD_RAY_RATIO]             // [1e9, num]
    dup1                        // [1e9, 1e9, num]
    dup3                        // [num, 1e9, 1e9, num]        
    mul                         // [num*1e9, 1e9, num]
    dup1                        // [num*1e9, num*1e9, 1e9, num]        
    dup3                        // [1e9, num*1e9, num*1e9, 1e9, num]
    swap1                       // [num*1e9, 1e9, num*1e9, 1e9, num]
    div                         // [num*1e9/1e9, num*1e9, 1e9, num]
    dup4                        // [num, num*1e9/1e9, num*1e9, 1e9, num]
    eq                          // [num==num*1e9/1e9, num*1e9, 1e9, num]
    iszero overflow jumpi        
    0x00 mstore                 // [1e9, num]
    0x20 0x00 return            // [1e9, num]
     
    return_zero:                
        0x00                    // [0]
        0x00 mstore             // []
        0x20 0x00 return        // []    
        
    overflow:
        revert
}
 
// /* Function Dispatcher */
// #define macro MAIN() = takes (0) returns (0) {
//     // Identify which function is being called.
//     0x00 calldataload 
    
//     // Extract the function signature
//     0xe0 shr

//     // Jump table
//     dup1 __FUNC_SIG(wadMul) eq  wad_mul jumpi
//     dup1 __FUNC_SIG(wadDiv) eq  wad_div jumpi
//     dup1 __FUNC_SIG(rayMul) eq  ray_mul jumpi
//     dup1 __FUNC_SIG(rayDiv) eq  ray_div jumpi
//     dup1 __FUNC_SIG(rayToWad) eq  ray_to_wad jumpi
//     dup1 __FUNC_SIG(wadToRay) eq  wad_to_ray jumpi


//     wad_mul:
//         WAD_MUL()

//     wad_div:
//         WAD_DIV()  

//     ray_mul:
//         RAY_MUL()  

//     ray_div:
//         RAY_DIV() 

//     ray_to_wad:
//         RAY_TO_WAD() 

//     wad_to_ray:
//         WAD_TO_RAY() 

// }



 