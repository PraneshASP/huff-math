
/* Interface */
#define function wadMul(uint256,uint256) nonpayable returns (uint256)
#define function wadDiv(uint256,uint256) nonpayable returns (uint256)
#define function rayMul(uint256,uint256) nonpayable returns (uint256)
#define function rayDiv(uint256,uint256) nonpayable returns (uint256)

 

// /* Constants*/
#define constant WAD = 0xde0b6b3a7640000
#define constant HALF_WAD = 0x6f05b59d3b20000
#define constant RAY = 0x33b2e3c9fd0803ce8000000
#define constant HALF_RAY = 0x19d971e4fe8401e74000000
#define constant WAD_RAY_RATIO = 0x3b9aca00
#define constant TYPE_UINT_MAX =  0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

 

/* Methods */
#define macro WAD_MUL() = takes (0) returns (0) {

    /// Short circuit: Return zero if one of the inputs are zero
    0x04 calldataload    // [num1] STACK=> { num1 }
    dup1
    iszero return_zero jumpi
    
    0x24 calldataload    // [num2] STACK=> { num1, num2 }
    dup1
    iszero return_zero jumpi
     

    ///(uint256_max - HALF_WAD) / num2 > num1
    [HALF_WAD] 
    [TYPE_UINT_MAX]
    sub 
    dup2
    dup2
    div
    dup4
    swap1 
    gt return_result jumpi
    
    return_zero:
        0x00
        0x00 mstore
        0x20 0x00 return
    
    return_result:
        pop
        mul
        [HALF_WAD]
        add
        [WAD]
        swap1
        div
        0x00 mstore
        0x20 0x00 return

}


#define macro WAD_DIV() = takes (0) returns (0) {
    0x04  calldataload     
      
    0x24 calldataload       
    dup1
    iszero revert_tx jumpi
    
    // half-b
    0x02
    swap1
    div
    dup1
    0x00 mstore
    //(type(uint256).max - halfB) / WAD > a
    [TYPE_UINT_MAX]
    sub 
    [WAD]
    dup2
    div
    dup3
    swap1 
    gt return_result jumpi
    
    revert_tx:
        revert

    //(a * WAD + halfB) / b
    return_result:
        pop
        [WAD]
        dup2
        mul
        0x00 mload
        add
        0x00 mload
        0x02
        mul
        swap1
        div
        0x00 mstore
        0x20 0x00 return
}


/* Methods */
#define macro RAY_MUL() = takes (0) returns (0) {

    /// Short circuit: Return zero if one of the inputs are zero
    0x04 calldataload    // [num1] STACK=> { num1 }
    dup1
    iszero return_zero jumpi
    
    0x24 calldataload    // [num2] STACK=> { num1, num2 }
    dup1
    iszero return_zero jumpi
     

    ///(uint256_max - HALF_RAY) / num2 > num1
    [HALF_RAY] 
    [TYPE_UINT_MAX]
    sub 
    dup2
    dup2
    div
    dup4
    swap1 
    gt return_result jumpi
    
    return_zero:
        0x00
        0x00 mstore
        0x20 0x00 return
    
    return_result:
        pop
        mul
        [HALF_RAY]
        add
        [RAY]
        swap1
        div
        0x00 mstore
        0x20 0x00 return

}

#define macro RAY_DIV() = takes (0) returns (0) {
    0x04  calldataload     
      
    0x24 calldataload       
    dup1
    iszero revert_tx jumpi
    
    // half-b
    0x02
    swap1
    div
    dup1
    0x00 mstore
    //(type(uint256).max - halfB) / WAD > a
    [TYPE_UINT_MAX]
    sub 
    [RAY]
    dup2
    div
    dup3
    swap1 
    gt return_result jumpi
    
    revert_tx:
        revert

    //(a * RAY + halfB) / b
    return_result:
        pop
        [RAY]
        dup2
        mul
        0x00 mload
        add
        0x00 mload
        0x02
        mul
        swap1
        div
        0x00 mstore
        0x20 0x00 return
}

 

#define macro MAIN() = takes (0) returns (0) {
    // Identify which function is being called.
    0x00 calldataload 
    
    // Extract the function singature
    0xe0 shr

    // Jump table
    dup1 __FUNC_SIG(wadMul) eq  wad_mul jumpi
    dup1 __FUNC_SIG(wadDiv) eq  wad_div jumpi
    dup1 __FUNC_SIG(rayMul) eq  ray_mul jumpi
    dup1 __FUNC_SIG(rayDiv) eq  ray_div jumpi


    wad_mul:
        WAD_MUL()

    wad_div:
        WAD_DIV()  

    ray_mul:
        RAY_MUL()  

    ray_div:
        RAY_DIV() 

}



 