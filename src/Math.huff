// Note: These are very basic impementation intended for learning. They don't check for overflows or underflows
// This was my first huff project :D

/* Methods */
#define macro ADD_NUMBERS() = takes (2) returns (1) {
    // Input stack:      // [num2, num1]
    add                  // [num2 + num1]         
}

#define macro SUB_NUMBERS() = takes (2) returns (1) {
    // Input stack:      // [num2, num1]
    swap1                // [num1, num2]
    sub                  // [num1 - num2]         
}


#define macro MULTIPLY_NUMBERS() = takes (2) returns (1) {
    // Input stack:      // [num2, num1]
    mul                  // [num2 * num1]         
}

#define macro DIVIDE_NUMBERS() = takes (2) returns (1) {
    // Input stack:      // [num2, num1]
    swap1                // [num1, num2]
    div                  // [num1 / num2]         
}


#define macro ABS() = takes (2) returns (1) {
    // Input stack:     // [num2, num1]
    dup1
    dup3
    lt 
    iszero swapAndSubtract jumpi
    sub                      
    complete jump  

    swapAndSubtract:
        swap1
        sub
    
    complete:
}

#define macro MOD_EXP() = takes (3) returns (1) {
    // Stack input: [base, exponent, modulus]

    // Check if modulus is zero, revert if it is
    dup1                   // Duplicate the modulus at the top of the stack
    0x00 eq                // Compare it to zero
    jumpi($MODULUS_NOT_ZERO) // Jump if not equal to zero
    0x00 0x00 revert       // If zero, revert

    // Label for non-zero modulus
    $MODULUS_NOT_ZERO:

    // Prepare memory for staticcall to precompiled contract at 0x05
    // First, we need to store the input data (base, exponent, modulus) in memory.
    // Assuming input is in the correct order on the stack: [base, exponent, modulus]
    0x20 0x00 mstore       // Store base at memory 0x20
    0x40 0x20 mstore       // Store exponent at memory 0x40
    0x60 0x40 mstore       // Store modulus at memory 0x60

    // Prepare input data for the precompiled contract
    // Input format: <length of base> <base> <length of exponent> <exponent> <length of modulus> <modulus>
    0x20 0x00 mstore       // Store length of base (0x20 bytes) at memory 0x00
    0x20 0x20 mstore       // Store base at memory 0x20
    0x20 0x40 mstore       // Store length of exponent (0x20 bytes) at memory 0x40
    0x20 0x60 mstore       // Store exponent at memory 0x60
    0x20 0x80 mstore       // Store length of modulus (0x20 bytes) at memory 0x80
    0x20 0xa0 mstore       // Store modulus at memory 0xa0

    // Set up the call to the precompiled contract
    0x00 0x00 0x00 0x05 gas // Address of the precompiled contract (0x05) and gas for the call
    0x00 0xc0              // Start of input data in memory and input data size (192 bytes)
    0x00 0x20              // Start of output data in memory and output data size (32 bytes)
    staticcall

    // Check if the call was successful
    iszero                 // If the call was not successful, the top of the stack will be 0
    jumpi($CALL_SUCCESSFUL) // Jump if successful
    0x00 0x00 revert       // If not successful, revert

    // Label for call success
    $CALL_SUCCESSFUL:
    0x00 0x20 mload        // Load the result from memory location 0x00
    // The result of base^exponent % modulus is now on top of the stack
}
